# techInterviewNote

### 基础排序

* 冒泡排序：比较相邻元素，如果顺序错误就交换。重复此步骤，直到数组有序。O(n^2)
* 选择排序：在未排序序列中找到最小（大）元素，和起始元素进行交换。 O(n^2)
* 插入排序：将未排序数组**插入**到已排序数组中， 适用于小规模数组。O(n^2)


### 进阶排序（理解思想）

* 快速排序
    *  是通过分治思想的排序算法，通过选择一个基准元素，将数组分成两部分。平均时间复杂度为O(nlogn)。最坏为O(n^2)。是一种不稳定的排序方法。

* 归并排序
    * 也是采用分治思想的排序算法，将数组分成两个子数组，分别排序后再合并。时间复杂度为O(nlogn)，是一种稳定的排序算法。空间复杂度为O(n)，需要额外的储存空间。

* 堆排序（为什么不用quickSort、mergeSort）

### 基础优化算法

* 贪心
    * 贪心算法是在每一步中都选取当前状态的最优解，希望通过局部最优解达到全局最优解。贪心算法的关键是证明贪心策略的正确性，并非所有问题都是和贪心算法。常见应用有活动选择问题、哈夫曼编码等。

* 哈希
    * 通过将元素放到特殊容器中实现快速插入和查找 O(1)。两数之和就是采用哈希表进行统计。

* 双指针
    * 双指针是指使用两个指针在数组或链表上移动，已解决一些特定问题。可以分为同向双指针和相向双指针，常用于查找子数组、链表有环等。

* 滑动窗口
    * 滑动窗口是一种特殊的双指针，通过维护一个固定大小的窗口在数组或字符串上移动。可以用于解决一些连续子数组或子字符串的问题，如最大子数组和。滑动窗口的关键是确定窗口的大小和移动。

* 二分
    * 二分查找是指在有序数组中查找某个元素的高效方法，O(logn)。二分查找的关键是确定查找区间和中间位置，不断缩小查找范围。应用于查找最大值、最小值等。

### 比较函数
* 看compare/student*.java


### 基本的搜索算法

* DFS： 深度优先。使用递归或栈来实现，适合寻找所有可能的解。可能陷入无限递归，注意边界条件。
    * 算法大致描述 -> 选择一个起始点u作为当前节点，执行如下操作：
        1. 访问当前节点，并标记该节点已被访问
        2. 如果存在一个和当前节点相邻并且尚未被访问的节点v，则将v设置为当前节点，继续执行1.
        3. 如果不存在这样的v，则进行回溯，回溯的过程就是回退当前节点。
    * 基础应用
        * 求阶乘（递归
        * 求斐波那契数列第n项（小数字用递归（大数字用记忆化搜索
        * 求n个数的全排列（DFS/FullPermutation
    * 进阶应用
        * 枚举：数据范围较小的排列、组合的穷举
        * 记忆化搜索：虽然叫记忆化搜索，但实际上还是动态规划问题，能够记忆化搜索的一般都能用动态规划求解，但是记忆化搜索更加直观、易写。(DFS/GoldenMine)
        * 容斥原理
        * 基于状态压缩的动态规划：一般解决棋盘的摆放问题
        * 有向图强连通分量（Tarjan algorithm
        * 无向图割边割点和双连通分量（Tarjan algorithm
        * LCA 最近公共祖先
        * 线段树：二分经典思想，配合深搜枚举左右子树，求和、最值等问题
        * 树形DP：父节点的值由各个子结点计算得出
    * 例题：https://blog.csdn.net/WhereIsHeroFrom/article/details/111407529 (DFS 题集)

* BFS：广度优先。使用队列来实现，适合寻找最短路径。空间复杂度高，需要存储节点信息。
    * 算法大致描述
        1. 初始化所有状态为无穷大，并且清空队列。
        2. 将起始状态放进队列，标记起始状态对应步数为0.
        3. 如果队列不为空，弹出队列首位元素，如果是结束状态，则返回结束状态对应步数。否则根据这个状态扩展状态继续压入队列。
        4. 如果队列为空，则说明没有找到结束状态，返回无穷大。
    * 预处理
        * 对于一些结束状态永远是固定的，而初始状态不同，并且询问很多的问题，那么我们可以从结束状态开始搜索，并且将到达的所有状态都一次性搜索出来，那么，每次询问的时候只需要查询状态步数即可，总复杂度就是预处理的时间，查询复杂度就是O(1)。
    * 基础应用
        * 最短路-绝大部分四向、八向迷宫的最短路径
        * 拓扑排序-有向无环图（Directed Acyclic Graph）才能拓扑排序，策略：将入度为0的元素入队，弹出元素然后执行"减度"操作，然后将减完度后为0的继续入队，循环操作直到队列为空。
        * FloodFill
        * 同余搜索
    * 例题：https://blog.csdn.net/WhereIsHeroFrom/article/details/111407529 (BFS 题集)
### 进阶数据结构

* 堆：一种完全二叉树，分为最大堆和最小堆。最大堆的每个节点都大于或等于其子节点的值，最小堆反之。可以用来实现**优先队列**(PriorityQueue)，支持插入和删除 O(logn)。
* 并查集：一种用于处理不相交集合的合并于查找问题。主要操作有查找和合并,接近O(1)。并查集常用于解决连通性问题，如判断图的连通分量。
* 树状数组：一种用于高效区处理区间查询和单点修改问题的数据结构O(logn)。实现基于二进制的思想。


### 进阶动态规划

* 01背包
    * 01背包是指选择若干物品放入背包，使背包中的价值最大化。每个物品只能选择放入或不放入。可以用二维或一维数组实现，时间复杂度为O(n * m)。n是物品数量，m是背包容量。

* 完全背包
    * 完全背包和01背包类似，但每个物品可以无限次放入背包。状态转移方程和01背包有所不i同，需要注意循环顺序。同样可以用一维或二维数组来实现，时间复杂度为O(n * m)。

* 多重背包
    * 多重背包是指每个物品有一定的数量限制，在一定的容量限制下选择物品使价值最大。可以通过二进制拆分将多重背包转化成01背包问题。时间复杂度为O(n * m *logk)，其中k是物品数量。

* 分组背包
    * 分组背包是指将物品分成若干组，每组中只能选择一个物品放入背包。状态转移方程需要考虑组内物品的选择，时间复杂度为O(n * m * g)，其中g是组数。分组背包可以用来解决一些资源分配问题。

* 区间DP
    * 区间DP是指在区间上进行动态规划的问题，通常需要枚举区间的长度和起点。状态转移方程通常与区间的和合并有关，时间复杂度为O(n^3)。区间DP用两个for循环写， 第一个for循环从区间长度小的枚举到大的。

* 数位DP
    * 数位DP是指在数字的每一位上进行动态规划的问题，常用于处理数字计数的问题。需要考虑数字的范围和限制条件，状态转移方程较为复杂。可以通过记忆化搜索或递推的方式实现，时间复杂度与数字的位数有关。数位DP用DFS来写。


### 图论算法

* 最短路径
    * Dijkstra
    * Bellman-Ford
    * Floyed
    * SPFA 是对 Bellman-Ford的优化
    * Dijkstra + Heap 是对Dijkstra的优化
* 最小生成树
    * prim
    * Kruskal 是对并查集的优化，要先学并查集

The path of jdk used: 'c:\Users\15103\.vscode\extensions\oracle.oracle-java-24.1.0\out\webviews\jdkDownloader\jdk_downloads\jdk-24.0.1'